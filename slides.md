# But Will It Scale?

Opening premise. Talk about design sessions, email lists, etc.

---

## Alternatively

- Build It
- Deploy It
- Fix It

---

# What's going on here?

---

## Scalable → _Awesome_

---

# Same meaning<br>more fun!

Release energy, move onto the real problems

---

# The Myth Of Scalability

---

# Outages

---

List some key outages from big players

---

## The World's Worst System

- SharePoint
- SQL Server
- Big Honkin' Enterprise Java App
- SOAP Interface

---

# Nothing Scales

---

# Everything Scales

---

# <strike>Scalability</strike> Suitability

---

<img src="cheetah.jpg" height="640px">

---

<img src="springbok.jpg" height="640px">

---

<img src="blackberries.jpg" height="640px">

---

<img src="turtle.jpg" height="640px">

---

<img src="alligator-vs-turtle.jpg" height="640px">

---

There's no such thing as fast, only fast enough.

-- Joe Armstrong

Get picture

---

## No such thing as premature optimization in nature

---

## No such thing as <strike>premature</strike> optimization in nature

---

# Optimization Fixation

---

## {{ Olympics logo here }}

---

## {{ Neanderthal picture }}

---

### {{ Four photos: hunting, evading prey, competing for mates, shelter/endurance }}

---

## Nature's Caprice

### {{ peahen }}

---

## Nature's Caprice

### {{ peacock }}

---

## Mate Selection Programming

---

## Very Scalable

---

## Very <strike>Scalable</strike> Awesome

---

## Scalability Anti Patterns

- Not a Problem
- Build It Naive
- Dependencies Bad
- Think "System"
- Physics Not Magic

---

# Not A Problem

---

If a problem has no solution, it may not be a problem,
but a fact--not to be solved, but to be coped with over time
— Shimon Peres (“Peres’s Law”)

---

# Build It Naive

---

## The Stupid Approach

- Obvious, line-of-sight
- Often works
- Often works forever
- Cheap
- Gets you to the actual problems

---

## Pointy Hair Argument

- Cost of work is _almost always_ under estimated
- Value of work is _often_ over estimated
- Keep work as small as possible, improve incrementally

---

# Dependencies Bad

---

## Down, but how?

---

### {{ Screen shot of the damn XML file that did it }}

---

### {{ Zoom in on the header }}

---

## Dependencies

- Moving part = part + interactions
- Part = tree of parts
- Parts you use can hurt you
- Parts you don't use can hurt you

---

## See "Build It Naive"

- Make due with what you have
- Fight each dependency until it overwhelms you
- When forced to give in, do so bitterly

---

# Think "System"

---

## Independencies

- Boundaries in time and space
- Not source code abstractions
- Some language cultures embrace system, others do not

---

# Physics Not Magic

---

Pyramid of latencies

---

## Buy These!

### {{ Photos of Raspberry PI, Ardino, Odroid }}

---

## Build This!

### {{ Some crazy racked setup with dozens of devices }}

---

# Complexity?

General place holder for talking about tipping points and other hard
to predict or reason about events. Hard to design for the future
because of this.

Use MySQL tipping point as an example.

---

# Solve Your Own Problems

This might be a good N point. It's easy to read a slide presentation
by XXX from Google and let that inform your thinking about your
problems. That's wrong.

I think this should probably be a pattern.

---

# ORMs Bad

What about this one? Abstractions that are just plain bad.

---

# Wrapping Up

- Embrace awesome!
- Then consider _suitability_
- And then _evolvability_

---

# Discussion

### Yell at me on Twitter!
## @gar1t
